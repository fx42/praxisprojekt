%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Stylish Article
% LaTeX Template
% Version 1.0 (31/1/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Mathias Legrand (legrand.mathias@gmail.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[fleqn,10.5pt,ngerman]{SelfArx}

\usepackage{babel}
\selectlanguage{ngerman}

\setlength{\columnsep}{0.55cm} % Distance between the two columns of text
\setlength{\fboxrule}{0.75pt} % Width of the border around the abstract

\definecolor{color1}{RGB}{0,0,90} % Color of the article title and sections
\definecolor{color2}{RGB}{0,20,20} % Color of the boxes behind the abstract and headings

\newlength{\tocsep} 
\setlength\tocsep{1.5pc} % Sets the indentation of the sections in the table of contents
\setcounter{tocdepth}{2} % Show only three levels in the table of contents section: sections, subsections and subsubsections


\usepackage{fontenc}
\usepackage{inputenc}
\usepackage{url} 
\usepackage{listings}


%----------------------------------------------------------------------------------------
%	ARTICLE INFORMATION
%----------------------------------------------------------------------------------------

\JournalInfo{Praxisbericht} % Journal information
\Archive{Wintersemester 16/17} % Additional notes (e.g. copyright, DOI, review/research article)

\PaperTitle{REST Anwendungsarchitektur} % Article title

\Authors{Max Mustermann} % Authors
\affiliation{\textit{Hochschule Kaiserslautern}} % Author affiliation
\affiliation{\textbf{Corresponding author}: max.mustermann@fh-kl.de} % Corresponding author

\Keywords{Web-Entwicklung, RESTful, SOA, JSON, Design, Java} % Keywords - if you don't want any simply remove all the text between the curly brackets
\newcommand{\keywordname}{Keywords} % Defines the keywords heading name

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\Abstract{Das Abstract ist eine maximal 200 Worte lange Zusammenfassung des Inhalts der Arbeit, so dass sich der Leser vorab ein erstes Bild vom Inhalt machen kann.}

%----------------------------------------------------------------------------------------

\begin{document}

\flushbottom % Makes all text pages the same height

\maketitle % Print the title and abstract box

\tableofcontents % Print the contents section

\thispagestyle{empty} % Removes page numbering from the first page

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section*{Einleitung} % The \section*{} command stops section numbering

\addcontentsline{toc}{section}{\hspace*{-\tocsep}Einleitung} % Adds this section to the table of contents with negative horizontal space equal to the indent for the numbered sections

Die Einleitung sollte ausreichenden Hintergrund für den Leser liefern, so dass er sich ohne großes Studium von Sekundärliteratur
in das Thema hineindenken kann. Auch sollte die Aufgabenstellung bzw. Motivation für die vorliegende Arbeit dargelegt werden, sowie die Zielsetzung, die man erreichen will. Weiter wird auch das Thema von eventuell verwandten Themen abgegrenzt. Hier kann auch die Literatur \cite{Harel:1987,Harel2006} und \cite{Gurp99onthe} vorgestellt werden.

Konkret sollt hier das Ziel und die Motivation des Projekts erläutert werden. Am Ende des Abschnitts steht eine kurze Übersicht über die weiteren Abschnitte.

Auch wenn die Einleitung zu Beginn der Arbeit liegt, wird sie oft erst am Ende verfasst.

%------------------------------------------------

\section{REST: State of the art}
Um zu verstehen, weshalb REST allgegenwärtig in der Entwicklung von Web-Applikationen ist, werden im Folgenden die Eigenschaften datiert, welche ein REST Interface spezifiziert. Um weiterhin die Unterschiede, sowie Vor- und Nachteile, zu diskutieren, wird eine Gegenüberstellung mit dem SOAP (\textit{Simple Object Access Protocol}) vorgenommen. 

\subsection{Paradigmen und Eigenschaften}
Die Aufbau aktueller Web-Applikationen beruht auf der Überlegung einer Service orientierten Kommunikation. Aufbauend auf der \textit{Service Oriented Aarchitecture(SOA)} wurde vom W3C die Definition für die noch heute gültige \textit{Web Services Architecture} \cite{WSA} festgelegt. Hier wird schon REST als Modell für das konstruieren für Web Services verwendet. Eine schematische Veranschaulichung finde sich Abbildung \ref{fig:rest}. Um jedoch eine REST-konforme Architektur zu realisieren wurden von Roy Thomas Fielding in seiner Dissertation \cite{Fielding:2000} eine Anzahl von Voraussetzungen festgeschrieben, die eine Architektur auf Basis von REST erfüllen muss:
\begin{figure}[ht]\centering
	\includegraphics[width=8.5 cm]{Abbildungen/restcommunication.jpg}
	\caption{Schematischer Aufbau WSA via REST}
	\label{fig:rest}
\end{figure}

\begin{itemize}
	\item \textbf{Client-Server:}\\ Der Ansatz der Client-Server Architektur soll verfolgt werden. Durch das Lösen der UI von den Daten der Applikation wird eine Portabilität, Skalierbarkeit und das Vereinfachen der Server-Komponente realisiert, was mittlerweile als Grundlage der kompletten Internet-Architektur gilt, denn der HTTP-Standard selbst beruht auf dieser Architektur.
	\item \textbf{Stateless:}\\ Die Zustandslosigkeit gilt für die Kommunikation zwischen Client und Server. Anfragen des Clients müssen alle Information enthalten um vom Server identifiziert und bearbeitet werden zu können. Einen Zustand oder Session-Informationen liegen somit komplett auf Seiten des Clients.
	\item \textbf{Cache:}\\ Die Antwort auf eine Client-Anfrage kann vom Server als cacheble oder non-cacheble gelabelt werden. Der Cache befindet sich auf der Client-Seite und erlaubt dem Client die Antwort für weitere Anfragen gleicher Art zu verwenden. Dadurch kann teilweise eine Kommunikation zwischen Client und Server unterbunden werden was die Performanz und Effizienz client-seitig stark erhöhen kann.
	\item \textbf{Uniform Interface:}\\ Das Uniform Interface repräsentiert das fundamentale Wesen eines REST-Services. Durch die Uniformierung jeder Ressource werden die Daten von der Architektur gelöst, was eine starke Entkopplung sowie Vereinfachung der Interaktion mit sich bringt. Weiterhin soll jeder Client die nötigen Information und Daten erhalten, die es ihm erlaubt, Ressourcen zu identifizieren und dadurch auch zu modifizieren. Die angefragte Ressource muss nicht die selbe Repräsentation auf Server- und Client-Seite besitzen. Objekte vom Server werden also zum Beispiel via XML oder JSON übertragen, enthalten die definierten Daten, müssen aber nicht dem Datentyp des Server-Objekts entsprechen. Nach Fieldings ist hier das \textit{Hypermedia as the engine of application state (HATEOAS)}-Prinzip mit der wichtigste Faktor. Dieses besagt, dass der Client alle Ressourcen nur über die definierten URI's beziehen kann. Durch diesen Zugang kann der Server dynamisch Daten kommunizieren und weiter verfügbare Adressen der Antwort hinzufügen. Somit wird verhindert, dass der Client fest codierte Information enthalten muss. Dadurch entsteht die Flexibilität des REST-Services.
	\item \textbf{Layered System:}\\ Dem Client muss nicht bekannt sein, ob die Kommunikation direkt mit dem Server stattfindet oder nicht. Die Anfrage wird gestellt und welcher Server aus einem Kollektiv die Antwort sendet, kann nicht zugeordnet werden. Dadurch können Prinzipien wie Load-Balancing und unterschiedliche Web-Sicherheitskriterien realisiert werden. 
	\item \textbf{Code on demand(optional):}\\ Dieser Schritt ist optional und beschreibt die Möglichkeit nach Anfrage ausführbaren Code vom Server zum Client zu transferieren, wie zum Beispiel Skripte in JavaScript. Somit kann der Server zeitweise die Funktionalität der Client-Applikation beeinflussen.
\end{itemize} 
\begin{figure}[ht]\centering
	\includegraphics[width=8.5 cm]{Abbildungen/RESTful-operations}
	\caption{Beschreibung der Standard HTTP Methoden in der REST-Architektur. Quelle: http://www.itersdesktop.com/}
	\label{fig:restCalls}
\end{figure}
Im Kontext von Web-Services, welche sich an die REST-Vorgaben binden, wird zumeist die Kommunikation über HTTP umgesetzt. Die API wird über eine Basis-URL angesprochen, über welche dann die benötigten Ressourcen angefragt werden müssen. HTTP bietet eine gewisse Anzahl an Standardmethoden(hauptsächlich: \textit{GET, PUT, POST, DELETE}) die auch für den Datentransfer in einer RESTful-API genutzt werden. Die grundlegenden Eigenschafen der Methoden finden sich im Bild \ref{fig:restCalls}. Diese Methoden repräsentieren auch die bekannten \textit{CRUD}-Operationen(Create, Read, Update, Delete) zur Datenverwaltung und Datenverarbeitung. Eine mögliche Variante mit den entsprechenden HTTP-Befehlen ist in der Tabelle \ref{tab:httptable} zu sehen. Es gilt weiterhin zu erwähnen, dass eine URL mit der entsprechenden HTTP-Methode als eindeutig gilt. Die URL kann jedoch mit einer weiteren HTTP-Methode genutzt werden. Dadurch wird festgelegt welche von den CRUD-Operation auf die entsprechende Ressource angewandt werden darf. 

\begin{table}[hbt]
	\caption{HTTP Methoden für spezifische URL's}
	\centering
	\begin{tabular}{ |p{2cm}|p{5.5cm}|}
		\toprule
		\cmidrule(r){1-2}
		URL & \textbf{http://api.example.com/res/item42}\\
		\midrule
		GET & Eine Repräsentation des Items42 wird an den Client übertragen\\
		\midrule
		POST & Wird zum Erstellen neuer Ressourcen verwendet, würde in diesem Fall eher nicht genutzt werden\\
		\midrule
		PUT & Item42 wird überschrieben oder erstellt wenn noch nicht vorhanden\\
		\midrule
		DELETE & Das adressierte Element Item42 wird gelöscht\\
		\bottomrule
	\end{tabular}\\
	\label{tab:httptable}
\end{table}

\subsection{REST vs. SOAP}
Bevor sich REST im Bereich der verteilten Anwendung etablierte, war die größte Vertreter für die Kommunikation innerhalb einer SOA das SOAP. Bei SOAP handelt es sich um eine RPC Middleware die zum Beispiel HTTP, SMTP oder FTP als Transportprotokoll für XML als Nachrichtenformat verwendet. Schon im grundsätzlichen Ansatz unterscheiden sich beide Herangehensweisen. Wird bei REST von einer exakten Uniformierung jeder Ressource gesprochen, die somit auch immer separat angesprochen werden können, so wird bei SOAP mit einem Dispacher gearbeitet. In sogenannten Envelopes werden alle Anfragen an den Server via XML mit dem HTTP-Post-Befehl an den zentralen Dispatcher geleitet. Die Anfrage gehen an genau eine URL die den Dispatcher adressiert. Im Listing \ref{envelopesoap} ist ein SOAP-Request mit seiner korrespondierenden Response zu sehen. Im Body wird eine \textit{GetStockPrice} Anfrage gestellt für das Unternehmen IBM. Im Body der Antwort wird somit die \textit{GetStockPriceResponse} mit dem Wert von 34,5 übermittelt. Die URL \textit{http://www.example.org/stock} spricht den Dispatcher des Webservers an. Dieser verteilt die Anfrage an die richtige Methode, hier \textit{GetStockPrice}. Diese Methode muss auf dem Server verfügbar sein. Durch die Anfrage wird ein Methodenaufruf mit den gelieferten Parametern durchgeführt. Das Ergebnis des Methodenaufrufs wird als Response in einem neuen Envelope zurück geliefert. Da jede Antwort einer exakten Anfrage gilt, ist ein erneutes stellen der gleichen Anfrage nicht möglich. Somit entfällt eine Möglichkeit caching auf Seiten des Clients zu betreiben.

\begin{lstlisting}[caption=Beispiel: SOAP-Request und SOAP-Response als Envelope, label=envelopesoap, language=xml]
 POST /InStock HTTP/1.1
Host: www.example.org
Content-Type: application/soap+xml; charset=utf-8
Content-Length: nnn

<?xml version="1.0"?>

<soap:Envelope
xmlns:soap="http://www.w3.org/2003/05/soap-envelope/"
soap:encodingStyle="http://www.w3.org/2003/05/soap-encoding">

<soap:Body xmlns:m="http://www.example.org/stock">
<m:GetStockPrice>
<m:StockName>IBM</m:StockName>
</m:GetStockPrice>
</soap:Body>

</soap:Envelope>

--------------------------------------------

 HTTP/1.1 200 OK
Content-Type: application/soap+xml; charset=utf-8
Content-Length: nnn

<?xml version="1.0"?>

<soap:Envelope
xmlns:soap="http://www.w3.org/2003/05/soap-envelope/"
soap:encodingStyle="http://www.w3.org/2003/05/soap-encoding">

<soap:Body xmlns:m="http://www.example.org/stock">
<m:GetStockPriceResponse>
<m:Price>34.5</m:Price>
</m:GetStockPriceResponse>
</soap:Body>

</soap:Envelope>
\end{lstlisting}
Ebenso wie REST wurde SOAP vom W3C spezifiziert. Unterschied ist allerdings, bei REST handelt sich um einen Architekturstil bei SOAP um ein Protokoll. in der Spezifikation steht zum Beispiel, dass ausschließlich XML als Datenformat verwendet wird und was ein XML wohl definiert um als SOAP konform zu gelten \cite{w3cSOAP}. Der Unterschied zu REST liegt hier darin, dass außer XML bei REST weitere Datenformate wie zum Beispiel JSON und YAML verwendet werden können. Die genaue Adressierung der Ressourcen unter REST erlaubt eine leichtgewichtige Transportmöglichkeit. Metadaten, wie das Encoding oder der Content-Type, werden im Header des HTTP-Requests codiert. Zusätzliche Information werden nicht benötigt. SOAP hingegen bietet diese Möglichkeit nicht. Durch die Konvention, welche Bestandteile ein XML-Envelope vorzuweisen hat, ist diese Leichtigkeit nicht zu erreichen. Das XML-Dokument muss auf Seiten des Sender aufgebaut und anschließen validiert werden um die Konformität zu bewahren. Dadurch werden zusätzliche Metadaten zur Beschreibung der Datei dem XML-Dokument hinzugefügt. Gerade bei einfachen Anfrage, zum Beispiel eine Zustandsabfrage wahr oder falsch, ist das Verhältnis von Nutz- zu Metadaten eher mäßig. Je aufwändiger die Anfrage desto besser entwickelt sich das Nutzlastenverhältnis. Anfragen eine XML-Dokuments werden immer atomar ausgeführt. Somit können komplexe Sachverhalte in einer Anfrage definiert werden und sequentiell abgearbeitet werden. Bei REST werden meist leichtgewichtige Schnittstellen exponiert die genau eine Anfrage nach einer bestimmten Ressource beantworten. Somit sind bei komplexeren Schritten mehre Anfragen nötig. Dadurch ist der Kommunikationsaufwand etwas höher als bei SOAP. Relativ ähnlich verhalten sich die beiden in Bezug auf die Interaktion. Da beide Plattform unabhängige Datenformate verwenden entfaltet sich ein großen Potenzial in der Nutzung. Programme jeglicher Art, entwickelt in einer belieben Programmiersprache, welche die Datenformate ebenso unterstützen, können mit den Schnittstellen interagieren. Bei REST muss eine API-Beschreibung mit den exponierten URL's, bei SOAP die URL mit den möglichen Methodenaufrufen öffentlich gemacht werden. Bei SOAP wird die Beschreibung meist als WSDL(\textit{Web Services Description Language}) \cite{w3cWSDL} vorgelegt. In dem WSDL-File werden alle Funktionen, Daten und Datentypen beschrieben. Es werden im wesentlichen die Operation definiert, die von außen zugänglich sind. Mit diesem WSDL-File wird auch die Validierung des XML-Dokuments durchgeführt. Es handelt sich auch hierbei um einen weiteren Standard definiert vom W3C.
\subsection{Evaluierung}
Durch die Kriterien welche Fieldings vorgibt, sowie durch den Vergleich mit SOAP haben sich einige Punkte heraus kristallisiert, welche hier nochmals kurz zusammen gefasst werden. \\ REST wird als leichte Schnittstelle definiert, in welcher jede URL eine exakte Ressource anspricht. Die Kommunikation findet über HTTP mit den üblichen HTTP-Methoden statt. Dem Client ist nicht bekannt man wem oder was die Kommunikation stattfindet was eine hohe Flexibilität und Skalierbarkeit generiert. Es müssen für alle benötigten Information immer die entsprechenden Requests angefragt werden, was wiederum zu einer starken Kommunikation mit Client und Server führt. Durch caching auf der Client-Seite kann dem etwas vorgebeugt werden. Meta-Informationen werden innerhalb des HTTP-Headers gespeichert und im Body befinden sich nur die Nutzdaten. Dadurch wird ein guten Nutzlastenverhältnis produziert. Die Information des Bodys kann in unterschiedlichen Datenformaten verschickt werden, was eine vielfältige Anwendungsmöglichkeit bietet. \\ Durch die vielen Vorteile ist leicht nachzuvollziehen wieso REST aktuell der vorherrschende Architektur Stil in Sachen Web-Anwendung ist. Im Bereich von großen Enterprise-Lösungen bis hin zu kleinen leichten Web-Anwendung zur Kommunikation mit einer mobilen Applikation werden mit REST realisiert. 

\section{Entwicklungsansatz und Aufbau}
Um zu Verstehen wie sich eine solche RESTful API zusammen setzt, wird in folgendem die grundlegende Spezifikation \textit{JAX-RS 2.0 - Java API for RESTful Web Services} vorgestellt. Anschließend wird ein in Java realisiertes Beispiel geschildert um die einzelnen Komponenten zu analysieren. 

\subsection{JAX-RS - die Basis für REST-Services in Java}
Bei JAX-RS handelt es sich um die Java eigene Programmierschnittstelle um das Entwickeln von Webservices unter Verwendung des Architekturstils REST zu vereinheitlichen. Die API wurde, bestehen aus einem Konsortium(u.a. Red Hat, Oracle, Fujitsu, Motorola) unter der Führung von Oracle/Sun Microsystems, entwickelt und spezifiziert. Die eigentliche Spezifikation \cite{jaxrs1.1} stammt aus dem Jahre 2009 und wird unter dem Java Specification Request \cite{spezreq} 311 geführt. Es wurden jedoch nicht alle Funktionalitäten in der Version 1 beziehungsweise 1.1 spezifiziert, was zur Folge hat, dass am Januar 2011 eine Arbeitsgruppe zur Entwicklung von JAX-RS 2.0 gegründet wurde. Die wichtigste Neuerung war das Realisieren des \textit{HATEOAS}-Prinzips. JAX-RS ist seit Java EE 6 Teil der Plattform. In Java SE sind die Schnittstellen standardmäßig nicht vorhanden und müssen separat als Abhängigkeiten geladen werden. Die Beschreibung des JSR 339 für JAX-RS 2.0 \cite{spezJSR339} beinhaltet noch weitere Informationen. Ebenso wird Jersey \cite{jersey} als Referenzimplementierung genannt. Sie stellt das Basis-Framework für die beiden JAX-RS API's. Um die meisten spezifizierten Eigenschaften dieser Java-API zu verwenden wie heutzutage üblich auf Annotationen zurück gegriffen. Sie vereinfachen das Entwickeln und die Übersicht und sind Hauptinitiator um Clients und Server REST-konform zu gestalten. Im folgenden Beispiel wird eine Applikation mit der schon erwähnten Implementierung Jersey 2.0 umgesetzt. Es gibt natürlich viele weitere Frameworks, wie zum Beispiel JBoss oder Spring. jedoch ist zur Veranschaulichung das Leichtgewicht Jersey ausreichend.

\subsection{Beschreibung der Beispielapplikation}
Das Szenario in welcher die Applikation genutzt werden soll lautet wie folgt: Ein Nutzer möchte sich sein eigenen Film-Portfolio anlegen. Er würde die Funktion gerne von seinem Rechner aber auch von seinem Smartphone aus benutzen können. Er möchte sich alle Filme die in seiner Liste sind anzeigen lassen, nach einem bestimmten Eintrag suchen, einen Eintrag hinzufügen oder einen Eintrag löschen. Beschrieben wird nun die auf dem Applikations-Server vorhandene Implementierung. \\ Das Projekt ist als Maven-Projekt umgesetzt und nutzt eine Version von Java SE. Alle Jersey-Abhängigkeiten sind somit in der \textit{pom.xml} definiert. Zusätzliche Abhängigkeiten sind \textit{Jackson} und \textit{Gson} zum mapping von Java-Objekten zum Json-Datenformat. Als Datenbankabhängigkeit wird die H2 InMemory-Datenbank verwendet. Da es sich nur um ein Beispiel handelt wurde kein eigenständiger Applikationsserver wie zum Beispiel Tomcat aufgesetzt. Stattdessen wurde auf die eigens dafür mitgebrachte JdkHttpServerFactory von Jersey zurückgegriffen. Diese erstellt zur Laufzeit einen entsprechenden HTTP-Server, sodass auch die Kommunikation via REST stattfinden kann. Die verwendete \textit{pom.xml} findet sich im Anhang in Listing \ref{pom.xml}.
Ein Überblick über den Aufbau der Applikation findet sich in Abbildung \ref{fig:overview}.
\begin{figure}[ht]\centering
	\includegraphics[width=6 cm]{Abbildungen/overview.jpg}
	\caption{Schematischer Überblick zur Movie-Portfolio Applikation}
	\label{fig:overview}
\end{figure}
\subsection{Serverseite Beispielimplementierung}
Im eben erwähnten Überblick lassen sich einige Information ableiten. Die Applikation exponiert eine Schnittstelle. Über diese kann Informationsaustausch in beide Richtungen stattfinden. Ebenso lässt sich erkennen, dass der \textit{MovieSerivce} als Interface abgebildet ist und die eigentliche Implementierung nachgelagert realisiert wird. In dem Schemata wird das Erstellen des vorab erwähnten HTTP-Servers nicht abgebildet. Da der eingebettete Server von Jersey verwendet wird, fällt die Konfiguration ziemlich gering aus. Die Initialisierung wird in der \textit{MainClass} beim starten der Anwendung direkt mit ausgeführt(vgl. Listing \ref{mainclass.java}). Als Ressourcen Konfiguration wird die Controller-Klasse angegeben. Diese enthält die Pfade und Methoden die vom HTTP-Server initialisiert werden sollen, sodass Aufrufe dementsprechend geroutet werden können. Die einzelnen Bestandteile werden in Folgendem im Detail beschrieben.
\lstinputlisting[language=Java, label=mainclass.java, caption={MainClass: Startklasse der Applikation. Startet HTTP-Server und initialisiert den REST-Controller}, emptylines=0, flexiblecolumns=false, firstline=10]{../code/RestExample/src/main/java/MainClass.java}
\subsubsection{MovieController}
Der Controller spiegelt die Schnittstelle programmatisch wider. Für alle Funktionalitäten werden hier die Pfade und die entsprechenden HTTP-Methoden festgelegt. Annotationen wie \textit{@GET} oder \textit{@POST} geben den zu verwendenden HTTP-Aufruf vor. Der Pfad setzt sich aus der Server-URL wie in Listing \ref{mainclass.java} zu sehen, ebenso aus den \textit{@PATH}-Annotationen an der Controller-Klasse sowie den entsprechenden Methoden zusammen. In Listing \ref{controller.java} sind diese Annotationen zu sehen. Um den Controller anzusprechen lautet der Pfad \textbf{http://localhost:8080/rest/movies}. Bei der ersten gelisteten \textit{GET}-Methode ist keine Erweiterung des Pfades nötig. Somit führt ein HTTP-GET auf \textit{http://localhost:8080/rest/movies} dazu, dass eine Anfrage nach allen in der Datenbank befindlichen Filmen gestellt wird. Die zweite Methode trägt die Erweiterung \textit{"movieId"}. Hierbei handelt es sich im einen in der URL codierten Parameter.  Somit liefert ein HTTP-GET auf \textit{http://localhost:8080/rest/movies/2} den Film mit der ID 2 aus der Datenbank, beziehungsweise \textit{null} wenn ein Film mit dieser ID nicht vorhanden ist. 
\lstinputlisting[language=Java, label=controller.java, caption={Ausschnitt aus der MovieController-Klasse}, emptylines=0, flexiblecolumns=false, firstline=8, lastline=31]{../code/RestExample/src/main/java/MovieController.java}
Als Rückgabewert wird in beiden Fällen eine HTTP-Response geliefert. Diese enthält bei einem GET-Request laut dem Standard(vgl .\cite{httpcodes}) den HTTP-Code \textit{200 OK}. Im Body werden die Objekte als Json geliefert. Die Annotation \textit{@Produces} besagt, dass Json als Datenformat verwendet werden soll. Das Gson-Objekt ermöglicht es Java-Objekte in das entsprechende Json-Format zu bringen. Ohne die korrekte Formatierung wäre eine Serialisierung der Objekte nicht möglich und es würde zu Fehlern in der Übertragung kommen. Die Definition der weiteren Methoden können im vollständigen Code des MovieController in Listing \ref{moviecontroller.java} gefunden werden. \\ Somit gilt der Controller nur als Berührungspunkt mit der Außenwelt. Die Funktionalität wird durch den darunter liegenden Service realisiert.
\subsubsection{MovieService-Interface}
Der MovieService selbst wurde in diesem Beispiel als Interface implementiert. Durch diese Instanz zwischen Controller und Service-Implementierung wird eine gewissen Stabilität gegenüber dem Controller gewährleistet jedoch kann man die verwendete Implementierung beliebig austauschen sofern die im Interface festgelegten Methoden überschrieben würden. Dadurch ergibt sich eine Flexibilität gegenüber der Service-Implementierung. 
\lstinputlisting[language=Java, label=serviceinterface.java, caption={MovieService Interface des Movie-Portfolios}, emptylines=0, flexiblecolumns=false]{../code/RestExample/src/main/java/MovieService.java}
In Listing \ref{serviceinterface.java} sind die gewünschten Funktionalitäten abgebildet. Wie es für jede spezielle Anfrage eine exakte URL gibt, wird auch jede Funktionalität mit einer eigenen Implementierung abgedeckt.
\subsubsection{MovieService-Implementierung}
Hierbei handelt es sich um die konkrete Implementierung der dem Interface zugrunde liegenden Funktionen. Da diese Beispielanwendung sehr klein gehalten ist, ist die einzige Aufgabe das Lesen und Schreiben der Datenbank. Hierzu wird nur die entsprechende Datenbank-Instanz benötigt. Der Programm-Code findet sich in Listing \ref{serviceimpl.java}.
\lstinputlisting[language=Java, label=serviceimpl.java, caption={MovieService Implementierung des Movie-Portfolios}, emptylines=0, flexiblecolumns=false]{../code/RestExample/src/main/java/MovieServiceImpl.java}
\subsection{Clientseite Beispielimplementierung}
Erläuterung der API, Bestandteile, Features 

\section{Frameworks? Microservice-Architektur?}

\section{Zusammenfassung}
Hier wird nochmal der Inhalt und die Ergebnisse der Arbeit erörtert. Im Ausblick werden Themen und Aufgabenstellungen genannt, die es lohnt weiter zu untersuchen.

\newpage
\clearpage
\appendix
\cleardoublepage
\onecolumn
%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\bibliographystyle{unsrt}
\bibliography{Literatur}

%----------------------------------------------------------------------------------------

\subsubsection*{Erklärung zur Ausarbeitung}
Hiermit erkläre ich, {\it Vorname Nachname (Matrikel)}, dass ich die vorliegende Ausarbeitung selbstständig und ohne fremde Hilfe angefertigt habe und keine anderen als in der Abhandlung angegebenen Hilfen benutzt habe; dass ich die Übernahme wörtlicher Zitate aus der Literatur sowie die Verwendung der Gedanken anderer Autoren an den entsprechenden Stellen innerhalb der Arbeit gekennzeichnet habe. Ich bin mir bewusst, dass eine falsche Erklärung rechtliche Folgen haben kann.\\ \\
--------------------- \\
Unterschrift


\clearpage
\appendix
\cleardoublepage
\newpage
\onecolumn

\section{Listings}
\lstinputlisting[language=XML, label=pom.xml, caption={POM.xml der Beispielanwendung}, emptylines=0, flexiblecolumns=false]{../code/RestExample/pom.xml}

\lstinputlisting[language=JAVA, label=moviecontroller.java, caption={Vollständiger Code des MovieControllers}, emptylines=0, flexiblecolumns=false]{../code/RestExample/src/main/java/MovieController.java}

\end{document}